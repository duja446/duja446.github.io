<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>clojure on Duja446 Blog</title><link>https://duja446.github.io/tags/clojure/</link><description>Recent content in clojure on Duja446 Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 18 Dec 2022 19:21:02 +0100</lastBuildDate><atom:link href="https://duja446.github.io/tags/clojure/index.xml" rel="self" type="application/rss+xml"/><item><title>Clojure - Pure Functions Powers</title><link>https://duja446.github.io/posts/2022-12-18-clojure-pure-functions-powers/</link><pubDate>Sun, 18 Dec 2022 19:21:02 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-18-clojure-pure-functions-powers/</guid><description>Pure Functions Powers Clojure provides functions that can derive new functions from old functions.
comp Composing pure functions is a common task in FP so Clojure provides comp to compose any number of functions to create a new function.
1((comp inc *) 2 3) 2; =&amp;gt; 7 Code written with comp is more elegant because it conveys more meaning.
memoize Memoization takes advantage of referential transparency by storing the arguments passed to a function and the return value of the function.</description></item><item><title>Clojure - Working With Immutable Data Structures</title><link>https://duja446.github.io/posts/2022-12-18-clojure-working-with-immutable-data-structures/</link><pubDate>Sun, 18 Dec 2022 19:01:09 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-18-clojure-working-with-immutable-data-structures/</guid><description>Recursion Insted of for/while I hate looping through a list in a language like JavaScript, because this creates imperative code that has side effects. Recursive functions may be difficult to read at first but with enough practice they become easier to read then imperative functions created with loops. Here is an example of how to build a sum function recursivly
1(defn sum 2 ([vals] (sum vals 0)) 3 ([vals accumulating-total] 4 (if (?</description></item><item><title>Clojure - Pure Functions</title><link>https://duja446.github.io/posts/2022-12-18-clojure-pure-functions/</link><pubDate>Sun, 18 Dec 2022 11:04:34 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-18-clojure-pure-functions/</guid><description>Pure Functions Pure functions are functions that:
always return the same result if given the same arguments - referential transparency don&amp;rsquo;t cause side effects Pure functions are easier to reason about because they are isolated and are unable to impact other parts of the program. Basicly they are stable and problem free as arithmetic.
Referential Transparency To achieve referential transparency pure function rely only on their own argument and immutable values to determine their return value.</description></item><item><title>Clojure - Lazy Seqs</title><link>https://duja446.github.io/posts/2022-12-18-clojure-lazy-seqs/</link><pubDate>Sun, 18 Dec 2022 09:11:56 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-18-clojure-lazy-seqs/</guid><description>Lazy Seqs Many functions that work on seqs return lazy seqs. Members of a lazy seq aren&amp;rsquo;t computed until they are needed. This has a benefit of making a program more efficient and allowing programmers to construct infinite sequences.
Efficiency 1(def database 2 {0 {:name &amp;#34;Bill&amp;#34; :age 40 :has-job? true} 3 1 {:name &amp;#34;Anna&amp;#34; :age 20 :has-job? false} 4 2 {:name &amp;#34;Dave&amp;#34; :age 17 :has-job? true} 5 3 {:name &amp;#34;Joe&amp;#34; :age 29 :has-job?</description></item><item><title>Clojure - Seq Functions</title><link>https://duja446.github.io/posts/2022-12-17-clojure-seq-functions/</link><pubDate>Sat, 17 Dec 2022 18:32:42 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-17-clojure-seq-functions/</guid><description>Seq Functions Clojure&amp;rsquo;s seq library has functions that work on Clojure&amp;rsquo;s sequence abstracion.
map Besides the main use of map it can also be used by taking multiple collections as arguments and taking a collection of functions as an argument.
1(map str [&amp;#34;a&amp;#34; &amp;#34;b&amp;#34; &amp;#34;c&amp;#34;] [&amp;#34;A&amp;#34; &amp;#34;B&amp;#34; &amp;#34;C&amp;#34;]) 2; =&amp;gt; (&amp;#34;aA&amp;#34; &amp;#34;bB&amp;#34; &amp;#34;cC&amp;#34;) When multiple collections are passed to map the elements of first collections will be passed as the first argument of the mapping function, second collection as second argument and so on.</description></item><item><title>Clojure - Functions</title><link>https://duja446.github.io/posts/2022-12-17-clojure-functions/</link><pubDate>Sat, 17 Dec 2022 08:52:40 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-17-clojure-functions/</guid><description>Functions Functions are a primary building block in Clojure. They can be used to craft complex programs from small and simple blocks.
Calling functions 1(+ 1 2 3 4) 2(* 1 2 3 4) 3(first [1 2 3 4]) In FP languages we treat functions as first class citizens meaning we can use them like any other datatype. This allows us to pass them to other functions making higher order functions - functions that take functions as parameters.</description></item><item><title>Clojure - Data Structures</title><link>https://duja446.github.io/posts/2022-12-16-clojure-structures/</link><pubDate>Fri, 16 Dec 2022 18:03:56 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-clojure-structures/</guid><description>Data Structures Clojure data structures are immutable meaning they can&amp;rsquo;t be changed in place like in many other programming languages.
Numbers Clojure has all the basic number representation found in other programming languages plus its own Ratio type. Ratio represents a division of integers that can&amp;rsquo;t be reduced to an integer.
92 1.8 1/3 Strings Strings can only be creted by using double quotes. Concatenation is done using the str function</description></item><item><title>Clojure - Syntax</title><link>https://duja446.github.io/posts/2022-12-16-clojure-syntax/</link><pubDate>Fri, 16 Dec 2022 17:43:56 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-clojure-syntax/</guid><description>Syntax Clojure syntax differs from many programming languages in that that it uses parantheses and indentation to construct code. The reason for this is that Clojure is a Lisp, a variant of the Lisp programming language.
Forms Clojure recognizes two kinds of structures:
literal representations of data structures (numbers, strings &amp;hellip;) operations Term form refers to an expression in Clojure.
11 2&amp;#34;hello world&amp;#34; 3[&amp;#34;vector&amp;#34; &amp;#34;of&amp;#34; &amp;#34;string&amp;#34;] Operations are how we do things.</description></item><item><title>Neovim Setup for Clojure</title><link>https://duja446.github.io/posts/2022-12-16-neovim-setup-for-clojure/</link><pubDate>Fri, 16 Dec 2022 17:07:15 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-neovim-setup-for-clojure/</guid><description>Neovim Setup for Clojure I am a big fan of Neovim so I will be altering my setup to make it easy and convenient for me to program in Clojure.
LSP For my LSP I am using the built in neovim lsp and williamboman/nvim-lsp-installer to install them. For Clojure I am using clojure-lsp.
1-- In lsp-installer.lua 2local status_ok, lsp_installer = pcall(require, &amp;#34;nvim-lsp-installer&amp;#34;) 3if not status_ok then 4 return 5end 6lsp_installer.setup {} 7 8local o = require(&amp;#39;user.</description></item><item><title>Learning Clojure</title><link>https://duja446.github.io/posts/2022-12-16-learning-clojure/</link><pubDate>Fri, 16 Dec 2022 16:34:35 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-learning-clojure/</guid><description>Learning Clojure My FP journey I first took interest in functional programming languages by learning about Haskell and being amazed by it. I was amazed by all the functional tools at my disposal and by the way they fit together. This started my journey on the path of learning more about functional programming.
After I had my fair share of fun with Haskell I quickly jumped to Erlang which was a programming language quite different from anything I had seen up until then.</description></item></channel></rss>