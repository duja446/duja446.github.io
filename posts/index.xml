<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Duja446 Blog</title><link>https://duja446.github.io/posts/</link><description>Recent content in Posts on Duja446 Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 17 Dec 2022 18:32:42 +0100</lastBuildDate><atom:link href="https://duja446.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Clojure - Seq Functions</title><link>https://duja446.github.io/posts/2022-12-17-clojure-seq-functions/</link><pubDate>Sat, 17 Dec 2022 18:32:42 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-17-clojure-seq-functions/</guid><description>Seq Functions Clojure&amp;rsquo;s seq library has functions that work on Clojure&amp;rsquo;s sequence abstracion.
map Besides the main use of map it can also be used by taking multiple collections as arguments and taking a collection of functions as an argument.
1(map str [&amp;#34;a&amp;#34; &amp;#34;b&amp;#34; &amp;#34;c&amp;#34;] [&amp;#34;A&amp;#34; &amp;#34;B&amp;#34; &amp;#34;C&amp;#34;]) 2; =&amp;gt; (&amp;#34;aA&amp;#34; &amp;#34;bB&amp;#34; &amp;#34;cC&amp;#34;) When multiple collections are passed to map the elements of first collections will be passed as the first argument of the mapping function, second collection as second argument and so on.</description></item><item><title>Clojure - Functions</title><link>https://duja446.github.io/posts/2022-12-17-clojure-functions/</link><pubDate>Sat, 17 Dec 2022 08:52:40 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-17-clojure-functions/</guid><description>Functions Functions are a primary building block in Clojure. They can be used to craft complex programs from small and simple blocks.
Calling functions 1(+ 1 2 3 4) 2(* 1 2 3 4) 3(first [1 2 3 4]) In FP languages we treat functions as first class citizens meaning we can use them like any other datatype. This allows us to pass them to other functions making higher order functions - functions that take functions as parameters.</description></item><item><title>Clojure - Data Structures</title><link>https://duja446.github.io/posts/2022-12-16-clojure-structures/</link><pubDate>Fri, 16 Dec 2022 18:03:56 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-clojure-structures/</guid><description>Data Structures Clojure data structures are immutable meaning they can&amp;rsquo;t be changed in place like in many other programming languages.
Numbers Clojure has all the basic number representation found in other programming languages plus its own Ratio type. Ratio represents a division of integers that can&amp;rsquo;t be reduced to an integer.
92 1.8 1/3 Strings Strings can only be creted by using double quotes. Concatenation is done using the str function</description></item><item><title>Clojure - Syntax</title><link>https://duja446.github.io/posts/2022-12-16-clojure-syntax/</link><pubDate>Fri, 16 Dec 2022 17:43:56 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-clojure-syntax/</guid><description>Syntax Clojure syntax differs from many programming languages in that that it uses parantheses and indentation to construct code. The reason for this is that Clojure is a Lisp, a variant of the Lisp programming language.
Forms Clojure recognizes two kinds of structures:
literal representations of data structures (numbers, strings &amp;hellip;) operations Term form refers to an expression in Clojure.
11 2&amp;#34;hello world&amp;#34; 3[&amp;#34;vector&amp;#34; &amp;#34;of&amp;#34; &amp;#34;string&amp;#34;] Operations are how we do things.</description></item><item><title>Neovim Setup for Clojure</title><link>https://duja446.github.io/posts/2022-12-16-neovim-setup-for-clojure/</link><pubDate>Fri, 16 Dec 2022 17:07:15 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-neovim-setup-for-clojure/</guid><description>Neovim Setup for Clojure I am a big fan of Neovim so I will be altering my setup to make it easy and convenient for me to program in Clojure.
LSP For my LSP I am using the built in neovim lsp and williamboman/nvim-lsp-installer to install them. For Clojure I am using clojure-lsp.
1-- In lsp-installer.lua 2local status_ok, lsp_installer = pcall(require, &amp;#34;nvim-lsp-installer&amp;#34;) 3if not status_ok then 4 return 5end 6lsp_installer.setup {} 7 8local o = require(&amp;#39;user.</description></item><item><title>Learning Clojure</title><link>https://duja446.github.io/posts/2022-12-16-learning-clojure/</link><pubDate>Fri, 16 Dec 2022 16:34:35 +0100</pubDate><guid>https://duja446.github.io/posts/2022-12-16-learning-clojure/</guid><description>Learning Clojure My FP journey I first took interest in functional programming languages by learning about Haskell and being amazed by it. I was amazed by all the functional tools at my disposal and by the way they fit together. This started my journey on the path of learning more about functional programming.
After I had my fair share of fun with Haskell I quickly jumped to Erlang which was a programming language quite different from anything I had seen up until then.</description></item></channel></rss>